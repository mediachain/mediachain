# ConCat: A System Design for Mediachain PME [Pre-critical Mass Era]

## Architecture

The system follows the RSS model, whereby individual peers maintain
and publish their own feeds for each namespace they participate in.
Readers can receive those feeds directly from publishers, either by
polling or by subscribing to a pubsub interface. Peers are free to
aggregate and republish any feed they subscribe to, thus creating a
network of concatinative feeds (hence ConCat).

In order to be discoverable, publishers advertise their feeds to
directory servers. Directory servers collect these advertisements
into the Universe, a comprehensive but uncurated directory where all
known peers and their feeds can be found.

In order to aid moderation and promotion of authoritative sources,
peer operators may elect to publicly identify their nodes.
Identification utilizes operator credentials backed by external
identity providers (blockstack, keybase, etc). In this way publishers
can be directly connected to real world entities and carry their
associated reputation with them.

The public identification allows directory servers to provide the next
stratum of discovery, by virtue of the Contrib directory. This
directory lists only verified nodes and allows discovery based on
operator identities (eg organizations, social media handles, keybase
user names and so on).

The final stratum of discovery, is the Glam directory. In this space,
directory servers recognize and promote autoritative sources and their
feeds. The recommendation model can be bootstrapped by utilizing
operator identities with a web of trust, whereby entities trusted by
directory servers can issue scoped endorsements for moderators and
publishers

## Peer Nodes

### Peer Identities
Every peer node is identified by an ECC public key. The key is
generated by the node when it is first set up and it is used for
signing all statements published by the node,

Each peer maintains its own local store, which is used for evaluating
queries locally and starts initially empty. The peer can extend its
local store by publishing new statements or by merging in feeds published
by other nodes. The merge can be the result of a one-off query, a
(perhaps irregular) polling operation, or it can be automatic by
subscribing to the publishers feed using the pubsub interface.
The peer may further elect to republish merged or subscribed feeds,
which aggregates source statements and republishes them with a wrapped
statement envelope.

### Peer Roles

Depending on their behaviour, peers can play three basic roles on each
namespace:

- Readers: these peers only merge feeds from other sources  and don't
  publish their own feeds. They act mostly as end user nodes or caches
  that can answer queries on their store.
- Publishers: these peers generate and publish their own statements in
  their feeds.
- Aggregators: these peers integrate feeds from other nodes and republish
  them, possibly in a different interface. Aggregators that don't generate
  their own statements but only republish feeds from other nodes are pure
  and they serve to enhance the network capacity.

### Peer Interface

The peer node interface can be distilled in the following rough schema:
```
interface PeerNode {
 identify(): Option[PeerInfo]               ; node info
 query(Query): QueryResult                  ; evaluate a query on the local store
 feeds(): List[FeedInfo]                    ; list published feeds
 subscribe(ns: String): Stream[Statement]   ; subscribe to a namespace feed
}

struct PeerInfo {
  id: PeerId           ; node id
  description: String  ; node description
  operator: OperatorId ; external id
  provider: String     ; external identity provider 
  sig: Signature       ; operator signature
}

struct FeedInfo {
 namespace: String
 sources:   List[PeerId]
}

```

## The Directory Interface

At a basic level, the directory provides a simple interface for peers
to register as publishers and discover other peers:

```
interface Directory {
 ; peer registration and advertisements
 register(PublisherInfo) ; register/refresh as publisher
 unregister()
 
 ; peer discovery
 lookup(PeerId): Option[PublisherInfo]              ; retrieve info for a peer
 list(dir: String, ns: String): List[PublisherInfo] ; list publishers for topic
}

struct PublisherInfo {
 id: PeerId
 addr: PeerAddress
 peer: Option[PeerInfo]
 feed: List[FeedInfo]
}
```

The basic directory interface is accessible to all peers, and also usable
by humans through a command line interface. A more advanced directory
interface can be provided through the web, which allows users to
browse, discover and endorse sources with a pleasant UX.

## Identity and Endorsement

## Implementation Notes

